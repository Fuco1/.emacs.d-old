(use-package haskell-mode
  :mode ("\\.hs\\'" . haskell-mode)
  :config
  (progn
    (require 'haskell-indentation)
    (bind-key "C-c h" 'haskell-hoogle haskell-mode-map)
    (bind-key "C-c C-r" 'my-haskell-reload haskell-mode-map)
    (bind-key "<backspace>" 'sp-backward-delete-char haskell-indentation-mode-map)

    (defun my-haskell-reload (&optional reload)
      (interactive)
      (inferior-haskell-load-file reload)
      (other-window 1))

;; (defun my-hs-end-of-defun (&optional arg)
;;       (interactive "p")
;;       (when (looking-at-p "$")
;;         (re-search-forward "^[[:alpha:]]")
;;         (backward-char))
;;       (let ((name (word-at-point)))
;;         (forward-char)
;;         (re-search-forward "^[[:alpha:]]")
;;         (beginning-of-line)
;;         (while (and (looking-at-p name)
;;                     (not (eobp)))
;;           (forward-line))
;;         (re-search-forward "^[[:alpha:]]")
;;         (backward-char 2)))

;; (defun my-hs-beg-of-defun (&optional arg)
;;   (interactive "p")
;;   (beginning-of-line)
;;   (let ((old-pos (point)))
;;     (when (looking-at-p "\\(\\s-\\|$\\)")
;;       (re-search-backward "^[[:alpha:]]"))
;;     (let ((name (word-at-point))
;;           (pos (point)))
;;       (while (and (looking-at-p name)
;;                   (not (bobp)))
;;         (forward-line -1))
;;       (forward-line)
;;       ;; (when (and (= pos (point))
;;       ;;            (= pos old-pos))
;;       ;;   (backward-char)
;;       ;;   (my-hs-beg-of-defun))
;;       )))

(defun my-hs-end-of-defun ()
  (forward-char)
  (re-search-forward "^[[:alpha:]]")
  (backward-char))

(defun my-hs-beg-of-defun ()
  (re-search-backward "^[[:alpha:]]"))

    (defun my-haskell-init ()
      (set (make-local-variable 'end-of-defun-function) 'my-hs-end-of-defun)
      (set (make-local-variable 'beginning-of-defun-function) 'my-hs-beg-of-defun))

    (add-hook 'haskell-mode-hook 'my-haskell-init)))
